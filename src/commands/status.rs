use crate::error::HookmanError;
use crate::models::HookType;
use crate::storage::{get_git_hooks_dir, get_hookman_dir, Storage, TomlStorage};
use anyhow::Result;
use colored::Colorize;
use std::fs;

pub fn execute() -> Result<()> {
    let storage = TomlStorage::new();

    if !storage.is_initialized() {
        return Err(HookmanError::NotInitialized.into());
    }

    let hookman_dir = get_hookman_dir()?;
    let git_hooks_dir = get_git_hooks_dir()?;

    println!("{}", "Hookman Status".bold());
    println!("{}", "=============".bold());
    println!();

    println!("Configuration directory: {}", hookman_dir.display());
    println!("Git hooks directory: {}", git_hooks_dir.display());
    println!();

    let configured_hooks = storage.list_hooks()?;

    if configured_hooks.is_empty() {
        println!("{}", "No hooks configured".yellow());
        return Ok(());
    }

    println!("{}", "Configured hooks:".bold());

    for hook_type in HookType::all() {
        let hook = storage.load_hook(hook_type)?;
        let git_hook_path = git_hooks_dir.join(hook_type.as_str());

        if hook.commands.is_empty() && !git_hook_path.exists() {
            continue;
        }

        print!("  {} ", hook_type);

        let status = if hook.commands.is_empty() {
            "no commands".yellow()
        } else if !git_hook_path.exists() {
            format!("{} commands, not applied", hook.commands.len()).red()
        } else if is_hookman_managed(&git_hook_path)? {
            format!("{} commands, applied", hook.commands.len()).green()
        } else {
            format!("{} commands, external hook exists", hook.commands.len()).yellow()
        };

        println!("- {}", status);
    }

    println!();
    println!("Use 'hookman apply' to apply pending changes");

    Ok(())
}

fn is_hookman_managed(path: &std::path::Path) -> Result<bool> {
    if !path.exists() {
        return Ok(false);
    }

    let content = fs::read_to_string(path)?;
    Ok(content.contains("Generated by hookman"))
}
